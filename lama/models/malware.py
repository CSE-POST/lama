"""
Malware class

This class represent a malware with many caracteristics like\
name, hash, size, mime type.
After analysis, malware contains some indicator which allow to say if\
it's a malware or not.

"""

__author__ = "Valentin Giannini"
__copyright__ = "Copyright 2016, LAMA"
__credits__ = [""]
__license__ = "GPL"
__version__ = "3"
__maintainer__ = "Valentin Giannini - CSE Team"
__email__ = "cse.contact -at- post.lu"
__status__ = "Production"


import magic
import shutil
import os.path
import hashlib
import logging
import mimetypes

from datetime import datetime, timedelta

import lama.models.analysis
import lama.models.dao.malware_dao
from lama.models.module_status import ModuleStatus

from lama.utils.file import File
from lama.utils.ftp import LamaFtp


class Malware(object):
    """Malware class

        Args :
            **uid** (Integer) : Uid of Malware

            **path** (String) : Remote path of malware

            **md5** (String) : MD5 hask of malware

            **sha1** (String) : SHA1 hack of malware

            **name** (String) : Name of malware

            **mime** (String) : Mime type of malware

            **size** (Integer) : Size of malware

            **module_status** (list) : Analysis module for this malware

            **extract_malware** (list) : list of extracted malware

            **parent_uid** (Integer) : Uid of parent malware

            **analysis_uid** (Integer) : Uid of analysis

            **nb_module** (Integer) : Number of analysis module for this malware

        Attributes :
            **_uid** (Integer) : Uid of Malware

            **_path** (String) : Remote path of malware

            **_md5** (String) : MD5 hask of malware

            **_sha1** (String) : SHA1 hack of malware

            **_name** (String) : Name of malware

            **_mime** (String) : Mime type of malware

            **_size** (Integer) : Size of malware

            **_module_status** (list) : Analysis module for this malware

            **_extract_malware** (list) : list of extracted malware

            **_parent_uid** (Integer) : Uid of parent malware

            **_analysis_uid** (Integer) : Uid of analysis

            **_nb_module** (Integer) : Number of analysis module for this malware
    """

    BLOCKSIZE = 65536

    def __init__(self, uid=None, path=None, md5=None, sha1=None, name=None,
                 mime=None, size=None,
                 module_status=None, extract_malware=None, parent_uid=None,
                 analysis_uid=None, nb_module=0):
        self._uid = uid
        self._path = path
        self._md5 = md5
        self._sha1 = sha1
        self._name = name
        self._mime = mime
        self._size = size
        self._module_status = module_status
        if self._module_status is None:
            self._module_status = []
        self._parent_uid = parent_uid
        self._extract_malware = extract_malware
        if self._extract_malware is None:
            self._extract_malware = []
        self._analysis_uid = analysis_uid
        self._nb_module = nb_module

    def empty_malware():
        m = Malware()
        res = m.persist()
        if not res:
            # TODO handle error
            logging.debug("Error persist malware")
        return m

    def factory(self, local_path, remote_path, name):
        """
        Return a Malware for given args.

        Args :
            **local_path** (String) : Local path of the malware

            **remote_path** (String) : Path on the FTP server

            **name** (String) : Name of the malware
        """
        # check if file exists
        if not os.path.isfile(local_path):
            print("{} is not a file".format(local_path))
            raise Exception()

        # compute md5 and sha1 digest
        md5_hash = hashlib.md5()
        sha1_hash = hashlib.sha1()
        # open file
        with open(local_path, 'rb') as malware_file:
            # loop for digest
            buf = malware_file.read(Malware.BLOCKSIZE)
            while len(buf) > 0:
                md5_hash.update(buf)
                sha1_hash.update(buf)
                buf = malware_file.read(Malware.BLOCKSIZE)
        md5 = md5_hash.hexdigest()
        sha1 = sha1_hash.hexdigest()
        mime = magic.from_file(local_path, mime=True)
        if isinstance(mime, bytes):
            mime = mime.decode('utf-8')
        ext = mimetypes.guess_extension(mime)
        if not ext:
            if "/x-" in mime:
                mime2 = mime.replace("/x-", "/")
                ext = mimetypes.guess_extension(mime2)
                if ext:
                    mime = mime2
        if ext:
            pass
            # name = name+ext

        size = os.path.getsize(local_path)

        self._name = name
        self._path = remote_path
        self._md5 = md5
        self._sha1 = sha1
        self._mime = mime
        self._size = size

        return self.name

    # TO BE TESTED
    def add_extract_malware(self, module_cls_name, content, malware_type=None):
        """
        Add a extracted malware to a malware.

        Args :
            **module_cls_name** (Sting) : Class name of the analysis module.

            **content** (String) : Content of the extracted malware.
        """
        # create the name with the name of current malware + "_extract_" + module classe name + rank number
        name = "{}_extract_{}_{}".format(self.name, module_cls_name,
                                         str(len(self._extract_malware)))
        # create file with the content
        tmp_dir_path = File.create_tmp_file(name, content)
        path = os.path.join(tmp_dir_path, name)
        # add the path to malware
        extract_malware = self.add_extract_malware_path(module_cls_name, path, name, malware_type=malware_type)

        # remove temporary file
        File.remove_tmp_dir(tmp_dir_path)
        return extract_malware

    def add_extract_malware_path(self, module_cls_name, path, name, malware_type=None):
        """
        Add a extracted malware to a malware with his path.
        It's for binary exctact.

        Args :
            **module_cls_name** (Sting) : Class name of the analysis module.

            **path** (String) : Path of the extracted malware.

            **name** (String) : Name of the extracted malware.
        """
        # create empty malware to have his uid
        m = Malware.empty_malware()
        # set link child/parent
        m._parent_uid = self.uid
        m.analysis_uid = self.analysis_uid
        # define the remote dir
        remote_dir = "{}/{}".format(str(m.analysis_uid),
                                    str(m.uid))
        # create the malware with other informations
        new_name = m.factory(path, remote_dir, name)
        if malware_type:
            m.mime = malware_type
        res = m.persist()
        if not res:
            # TODO handle error
            logging.debug("Error persist malware")
        # send to FTp server
        LamaFtp.upload(path, remote_dir, new_name)
        # add the extracted malware to the list of extracted malware
        self._extract_malware.append(m)
        return m

    def set_module_status(self, module_cls_name, status):
        """
        Change the status of given module.
        """
        set_ = False
        # check if ms exists
        for ms in self._module_status:
            if ms.module_cls_name == module_cls_name:
                ms.change_status(status)
                res = ms.persist()
                if not res:
                    # TODO handle error
                    logging.debug("Error persist modulestatus")
                set_ = True

        if not set_:
            # if not exists : add it
            ms = ModuleStatus.factory(module_cls_name, status)
            ms.malware_uid = self.uid
            self._module_status.append(ms)
            res = ms.persist()
            if not res:
                # TODO handle error
                logging.debug("Error persist modulestatus")

    def is_finish(self):
        """
        Check the state of malware
        If all status are finished, the malware analysis is finish.
        """
        if self.nb_module > 0:
            if self.nb_module == len(self._module_status):
                for ms in self._module_status:
                    if not ms.is_finish():
                        return False
                for m in self._extract_malware:
                    if not m.is_finish():
                        return False
                return True
            else:
                return False
        else:
            return False

    def add_options_module_status(self, module_cls_name, options):
        """
        Add option to module status
        """
        for ms in self._module_status:
            if ms.module_cls_name == module_cls_name:
                ms.add_options(options)
                res = ms.persist()
                if not res:
                    # TODO handle error
                    logging.debug("Error persist modulestatus")

    def get_module_status(self, module_cls_name):
        """
        Return the status of given module.
        """
        for ms in self._module_status:
            if ms.module_cls_name == module_cls_name:
                return ms

    def compute_stat(self):
        """
        Compute stats of malware like :

        - Average score
        - Max score
        - Min score
        """
        stats = {}
        stats['score_avg'] = 0
        stats['score_max'] = 0
        stats['nb_not_null'] = 0
        stats['ms'] = []
        for ms in self._module_status:
            stat = ms.compute_stat()
            stats['ms'].append(stat)
            # for ms_stats in stats['ms']:
            x = stat['avg']
            if x > 0:
                stats['score_avg'] += x
                stats['nb_not_null'] += 1
                if x > stats['score_max']:
                    stats['score_max'] = x

        if stats['nb_not_null'] > 0:
            stats['score_avg'] = stats['score_avg'] / stats['nb_not_null']
        return stats

    def get_queue_uid(self):
        """
        Return an uid to identify the malware into queues.
        It's \{uid\}-\{MD5\}-\{SHA1\} format.
        """
        return "{}-{}-{}".format(self._uid, self._md5, self._sha1)

    def download(self):
        """
        Download the malware on local machine.
        """
        local_path, _ = LamaFtp.download_to_tmp(str(self.analysis_uid)+"/"+str(self.uid)+"/"+self.name)
        return local_path

    def delete_download(self, local_path):
        """
        Remove downloaded malware
        """
        if "lama_" in local_path:
            shutil.rmtree(local_path)

    def add_nb_module(self):
        """
        Increment the number of analysis module for the malware.
        """
        self._nb_module += 1

    def __str__(self):
        return (
            "-----------------------------------------------\n"
            "Name   \t{}\n"
            "Mime   \t{}\n"
            "Path   \t{}\n"
            "Size   \t{}\n"
            "MD5    \t{}\n"
            "SHA1   \t{}\n"
            "nb mod  {}\n"
            "analysis uid  {}\n"
            "module status\n\t************\n\t{}\n"
            "extract\n\t************\n\t{}\n"
            ).format(
                    self.name, self.mime, self.path, self._size,
                    self.md5, self.sha1, self.nb_module, self.analysis_uid,
                    '\t'.join(("************\n"
                               .join(f.__str__() for f in self.module_status))
                              .splitlines(True)),
                    '\t'.join(("************\n"
                               .join(f.__str__() for f in self.extract_malware))
                              .splitlines(True)))

    @property
    def uid(self):
        """
        Return the uid of malware.
        """
        return self._uid

    @property
    def parent_uid(self):
        """
        Return the uid of malware.
        """
        return self._parent_uid

    @property
    def name(self):
        """
        Return the name of malware.
        """
        return self._name

    @property
    def mime(self):
        """
        Return the mime type of malware.
        """
        return self._mime

    @mime.setter
    def mime(self, mime):
        self._mime = mime

    @property
    def path(self):
        """
        Return the path of malware.
        """
        return self._path

    @property
    def size(self):
        """
        Return the size of malware.
        """
        return self._size

    @property
    def md5(self):
        """
        Return the MD5 digest of malware.
        """
        return self._md5

    @property
    def sha1(self):
        """
        Return the SHA1 digest of malware.
        """
        return self._sha1

    @property
    def nb_module(self):
        """
        Return the number of module for analyse
        """
        return self._nb_module

    @property
    def module_status(self):
        """
        Return the list of module status of malware.
        """
        return self._module_status

    @property
    def analysis_uid(self):
        return self._analysis_uid

    @analysis_uid.setter
    def analysis_uid(self, analysis_id):
        self._analysis_uid = analysis_id

    @property
    def extract_malware(self):
        return self._extract_malware

    # DATABASE SECTION

    def persist(self):
        """
        Persist the malware and all indicator in the database.

        Args :
            **commit** (bool): Indicate if we want to commit.
        """
        if self._uid:
            # update
            res = lama.models.dao.malware_dao.MalwareDAO.update(self)
        else:
            # insert
            res = lama.models.dao.malware_dao.MalwareDAO.create(self)

        if not res:
            return False

        for ms in self.module_status:
            ms._malware_uid = self._uid
            res = ms.persist()
            if not res:
                return False
        return True

    @staticmethod
    def delete(uid):
        """
        Static method.
        Delete malware by uid
        """
        malware = lama.models.dao.malware_dao.MalwareDAO.read(uid)
        for em in malware.extract_malware:
            Malware.delete(em.uid)
        for ms in malware.module_status:
            lama.models.module_status.ModuleStatus.delete(ms.id)
        lama.models.dao.malware_dao.MalwareDAO.delete(uid)

    @staticmethod
    def find_by_uid(uid):
        """
        Static method.
        Find analysis by uid.

        Args :
            **uid** (int): uId of malware.
        """
        pass

    @staticmethod
    def find_by_queue_uid(queue_uid):
        """
        Static method.
        Find analysis by queue_uid.

        Args :
            **queue_uid** (int): Queue_uid of malware.
        """
        uid, md5, sha1 = queue_uid.split("-")
        malware = lama.models.dao.malware_dao.MalwareDAO.read(uid)
        if malware.md5 == md5 and malware.sha1 == sha1:
            return malware
        else:
            # TODO add Exception
            return None
